pipeline {
    agent {
        label 'aws-slave'
    }

    environment {
        AWS_REGION = 'us-east-1'
        APP_DIR = 'journalapp'
        TERRAFORM_DIR = 'terraform'
        ECR_REPO_URI = '471112618663.dkr.ecr.us-east-1.amazonaws.com/springboot-app-repo'
        DOCKER_IMAGE = ''
    }

    stages {
        // STAGE 1: Checkout from GitHub
        stage('Checkout Code') {
            steps {
                cleanWs()
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/main']],
                    userRemoteConfigs: [[
                        url: 'https://github.com/GitAzeem/springboot-aws-pipeline.git',
                        credentialsId: 'github-cred'
                    ]]
                ])
                script {
                    COMMIT_HASH = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    env.DOCKER_IMAGE = "${env.ECR_REPO_URI}:${COMMIT_HASH}-${BUILD_NUMBER}"
                }
            }
        }

        // STAGE 2: Build Spring Boot
        stage('Build Application') {
            steps {
                dir(env.APP_DIR) {
                    sh './mvnw clean package -DskipTests'
                    archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
                }
            }
        }

        // STAGE 3: Docker Operations
        stage('Containerize') {
            steps {
                withCredentials([aws(credentialsId: 'aws-creds')]) {
                    script {
                        // Login to ECR
                        sh """
                            aws ecr get-login-password --region ${env.AWS_REGION} | \
                            docker login --username AWS --password-stdin ${env.ECR_REPO_URI.split('/')[0]}
                        """

                        // Build and push Docker image
                        dir(env.APP_DIR) {
                            sh "docker build -t ${env.DOCKER_IMAGE} ."
                            sh "docker push ${env.DOCKER_IMAGE}"
                        }
                    }
                }
            }
        }

        // STAGE 4: Terraform Deploy
        stage('Provision Infrastructure') {
            steps {
                dir(env.TERRAFORM_DIR) {
                    withCredentials([aws(credentialsId: 'aws-creds')]) {
                        sh 'terraform init -upgrade'
                        sh """
                            terraform apply -auto-approve \
                                -var="docker_image=${env.DOCKER_IMAGE}" \
                                -var="region=${env.AWS_REGION}" \
                                -var="instance_type=t3.small" \
                                -var="key_name=main"
                        """
                    }
                }
            }
        }

        // STAGE 5: Deployment Verification
        stage('Verify Deployment') {
            steps {
                script {
                    def FRONTEND_IP = sh(
                        script: 'terraform output -raw frontend_public_ip',
                        dir: env.TERRAFORM_DIR,
                        returnStdout: true
                    ).trim()

                    def BACKEND_IP = sh(
                        script: 'terraform output -raw backend_private_ip',
                        dir: env.TERRAFORM_DIR,
                        returnStdout: true
                    ).trim()

                    // Test frontend (nginx)
                    sh "curl -sSf http://${FRONTEND_IP} --retry 3 --retry-delay 5"
                    
                    // Test backend (Spring Boot via private IP)
                    sh """
                        ssh -o StrictHostKeyChecking=no -i /path/to/main.pem ubuntu@${FRONTEND_IP} \
                        "curl -sSf http://${BACKEND_IP}:9090/health --retry 3"
                    """
                }
            }
        }
    }

    post {
        always {
            script {
                // Clean up Docker images to save space
                sh 'docker system prune -af || true'
                
                // Archive Terraform output
                dir(env.TERRAFORM_DIR) {
                    archiveArtifacts artifacts: '*.tfstate*', allowEmptyArchive: true
                }
            }
        }
        failure {
            script {
                echo "Initiating rollback procedures..."
                dir(env.TERRAFORM_DIR) {
                    // Only destroy if resources were created
                    if (fileExists('terraform.tfstate') && 
                        sh(script: 'terraform state list | wc -l', returnStdout: true).trim().toInteger() > 0) {
                        sh 'terraform destroy -auto-approve'
                    }
                }
                emailext body: "Pipeline failed in stage ${currentBuild.currentResult}\nBuild URL: ${BUILD_URL}",
                      subject: "FAILED: ${env.JOB_NAME} - Build ${env.BUILD_NUMBER}",
                      to: 'your-email@example.com'
            }
        }
        success {
            script {
                def FRONTEND_URL = sh(
                    script: 'terraform output -raw frontend_public_ip',
                    dir: env.TERRAFORM_DIR,
                    returnStdout: true
                ).trim()
                
                emailext body: """
                    Pipeline succeeded!
                    Frontend URL: http://${FRONTEND_URL}
                    Deployed image: ${env.DOCKER_IMAGE}
                    Build URL: ${BUILD_URL}
                """,
                subject: "SUCCESS: ${env.JOB_NAME} - Build ${env.BUILD_NUMBER}",
                to: 'your-email@example.com'
            }
        }
    }
}